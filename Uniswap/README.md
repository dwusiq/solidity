# Uniswap

## 一、概况
* 自动做市商(`AMM`),没有订单簿，自动促成交易。
* 池子由任意两个不相同的`token`组成，并且任何人可以自由的增加或减少自己的流动性份额。
* 池内两个`token`的乘积恒定：`k=x*y`（但是实际上，由于交易费会使其中一个值变大，因此`k`也在慢慢变大）。
* 用户兑换`token`,需要扣除手续费，手续费给提供流动性的所有用户平分。
* 用户向池子添加流动性，合约扣除用户的`tokenPair`，并给用户铸造`lpToken`。
* 用户移除流动性，合约扣除用户`lpToken`,并返`tokenPair`的相应份额。

## 二、合约简述
* `factory`：工厂合约，支持创建和检索任意不同的`pair`。
* `pair`: 属于`ERC20`规范的合约， 每个交易对都是一个`pair`合约的实例。
* `router`:  提供一些方便简化用户操作的接口，如新增、减少流动性，兑换份额计算等。

## 三、其它关注点
#### 价格预言
* 由于套利者的存在，因此`uniswap`的价格会趋于市场的实际价格，因此可以作为价格参考。
#### 精度
* `solidity`的一个插槽存储`256`位，`uniswap`使用`UQ112x112`来表示`token`的价格(即表示小数`unit112.unit112`),前面`112`位存储整数值(即最大`2^112-1`),后面`112`位保存小数值(即最大`2^112-1`),还有中间的`32`位用来存储此刻价格对应的时间戳。4

#### 部分存储变量
* `price0CumulativeLast`和`price1CumulativeLast`。记录交易对中两种价格的累计值,价格预言用户可以自己存储这个两个值来提供价格信息。
* `uint public kLast;`记录某一时刻恒定乘积中积的值，主要用于开发团队手续费计算。
* `reserve0`,`reserve1`和`blockTimestampLast`这三个状态变量记录了最新的恒定乘积中两种资产的数量和交易时的区块（创建）时间。
* `uint public constant MINIMUM_LIQUIDITY = 10**3;`定义了最小流动性。它是最小数值1的1000倍，用来在提供初始流动性时燃烧掉。

## 三、版本对比
#### `V2` vs `V3`
* `V3`用户可以选择在哪个价位区间提供流动性，如果在这个价格区间内有交易，则该用户可以有交易费